package main

import (
	aiozapp "aioz.io/go-aioz/app"
	"aioz.io/go-aioz/types"
	"bufio"
	"context"
	"errors"
	firebase "firebase.google.com/go/v4"
	"fmt"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/labstack/echo/v4"
	mw "github.com/labstack/echo/v4/middleware"
	"github.com/spf13/viper"
	echoSwagger "github.com/swaggo/echo-swagger"
	"google.golang.org/api/option"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
	"log"
	"net/http"
	"os"
	blacklisthandler "swagger-server/blacklisting/delivery/http"
	blacklistrepo "swagger-server/blacklisting/repository/file"
	blacklistusecase "swagger-server/blacklisting/usecase"
	bhandler "swagger-server/block/delivery/http"
	blockrepo "swagger-server/block/repository/cockroachdb"
	busecase "swagger-server/block/usecase"
	svctx "swagger-server/context"
	delegatorhandler "swagger-server/delegator/delivery/http"
	delegatorrepo "swagger-server/delegator/repository/cockroachdb"
	delegatorusecase "swagger-server/delegator/usecase"
	devicehandler "swagger-server/devices/delivery/http"
	devicerepo "swagger-server/devices/repository/cockroachdb"
	deviceusecase "swagger-server/devices/usecase"
	"swagger-server/domain"
	lcdusecase "swagger-server/lcd_client/usecase"
	svlog "swagger-server/log"
	"swagger-server/middleware"
	txshandler "swagger-server/msgs/delivery/http"
	msgsrepo "swagger-server/msgs/repository/cockroachdb"
	txsusecase "swagger-server/msgs/usecase"
	nodehandler "swagger-server/nodeInfo/delivery/http"
	noderepo "swagger-server/nodeInfo/repository/cockroachdb"
	nodeusecase "swagger-server/nodeInfo/usecase"
	stakinghandler "swagger-server/staking/delivery/http"
	stakingrepo "swagger-server/staking/repository/cockroachdb"
	stakingusecase "swagger-server/staking/usecase"
	stathandler "swagger-server/statistic/delivery/http"
	statrepo "swagger-server/statistic/repository/cockroachdb"
	statusecase "swagger-server/statistic/usecase"
	txhandler "swagger-server/transaction/delivery/http"
	txrepo "swagger-server/transaction/repository/cockroachdb"
	txusecase "swagger-server/transaction/usecase"
	validatorhandler "swagger-server/validator/delivery/http"
	validatorrepo "swagger-server/validator/repository/cockroachdb"
	validatorusecase "swagger-server/validator/usecase"
	wallethandler "swagger-server/wallet/delivery/http"
	walletrepo "swagger-server/wallet/repository/cockroachdb"
	walletusecase "swagger-server/wallet/usecase"
	"swagger-server/ws"

	//docs is generated by Swag CLI, you have to import it.
	_ "swagger-server/docs"
)

// @title Swagger Example API
// @version 1.0
// @description This is a sample server Petstore server.
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

// @host 10.0.0.105:7080
// @BasePath /api

var (
	serverHostName string
	authServer     string
	firebaseCred   string

	rpcurl      string
	rpcendpoint string

	wsnodeurl      string
	wsnodeendpoint string

	wsserver *ws.WS
	db       *gorm.DB
	app      *firebase.App

	blacklistingIP = make(map[string]bool)
	whitelistingIP = make(map[string]bool)
	fileBlacklist  *os.File
	fileWhitelist  *os.File
	rate           int
	burst          int
)

func init() {
	viper.SetConfigFile(`config.json`)
	err := viper.ReadInConfig()
	if err != nil {
		panic(err)
	}
	if viper.GetBool(`debug`) {
		fmt.Println("Service RUN on DEBUG mode")
	}
	configHost := viper.Get("server.host")
	configPort := viper.Get("server.port")
	// should return the value in a default format
	serverHostName = fmt.Sprintf("%v:%v", configHost, configPort)
	configAuthHost := viper.Get("authentication.host")
	//configAuthPort := viper.Get("authentication.port")
	authServer = fmt.Sprintf("%v", configAuthHost)
	log.Println("[main] Server authentication on url", authServer)
	log.Println("[main] Server listening on url", serverHostName)

	firebaseCred = viper.GetString("firebase_key.path")
	rpcurl = viper.GetString("rpc.path")
	rpcendpoint = viper.GetString("rpc.endpoint")

	wsnodeurl = viper.GetString("wsnode.url")
	wsnodeendpoint = viper.GetString("wsnode.endpoint")

	// init app cdc
	sdkConfig := sdk.GetConfig()
	sdkConfig.SetBech32PrefixForAccount(types.Bech32PrefixAccAddr, types.Bech32PrefixAccPub)
	sdkConfig.SetBech32PrefixForValidator(types.Bech32PrefixValAddr, types.Bech32PrefixValPub)
	sdkConfig.SetBech32PrefixForConsensusNode(types.Bech32PrefixConsAddr, types.Bech32PrefixConsPub)
	sdkConfig.SetCoinType(types.CoinType)
	sdkConfig.SetFullFundraiserPath(types.FullFundraiserPath)
	sdkConfig.Seal()

	// init new cockroachdb
	db = initCockroachDB()

	// init firebase app
	app = initFirebase()

	// load blacklist IP to map
	rate = viper.GetInt("limit.rate")
	burst = viper.GetInt("limit.burst")
	fileBlacklist, _ = os.Open(viper.GetString("blacklist.path"))
	scanner := bufio.NewScanner(fileBlacklist)
	for scanner.Scan() {
		blacklistingIP[scanner.Text()] = true
	}
	if err := scanner.Err(); err != nil {
		log.Fatal(err)
	}

	fileWhitelist, _ = os.Open(viper.GetString("whitelist.path"))
	scanner = bufio.NewScanner(fileWhitelist)
	for scanner.Scan() {
		whitelistingIP[scanner.Text()] = true
	}
	if err := scanner.Err(); err != nil {
		log.Fatal(err)
	}
	defer func() {
		fileBlacklist.Close()
		fileWhitelist.Close()
	}()

}

func main() {
	// setup logger
	svlogger := svlog.ServerLogger()
	ctx := svctx.NewServerContext(svlogger)
	// setup new echo server
	e := echo.New()
	//auth := middleware.NewAuthRepo(authServer)
	//mdl := middleware.InitMiddleware(auth)
	//e.Use(mdl.Authorize)

	// using rate-limit
	e.Use(middleware.RateLimitWithConfig(middleware.RateLimitConfig{
		Limit:          rate,
		Burst:          burst,
		BlacklistingIP: blacklistingIP,
		WhitelistingIP: whitelistingIP,
	}))

	// using tollbooth_echo
	// this set 20r/s, but actual testing show it is x2?!
	//e.Use(middleware.TollBoothRateLimit(50))

	e.Use(mw.Logger())
	e.Use(mw.CORSWithConfig(mw.CORSConfig{
		AllowOrigins: []string{"*"},
		AllowMethods: []string{http.MethodPut, http.MethodPost, http.MethodGet, http.MethodOptions},
	}))
	g := e.Group("/api")

	// init codec
	cdc := aiozapp.MakeCodec()

	// websocket client, use to connect to ws on node
	wsclient := ws.NewWSClient(ctx, wsnodeurl, wsnodeendpoint,
		ws.OnDisconnect(onDisconnectFromWsNode),
		ws.OnReconnect(onReconnectToWsNode))
	err := wsclient.Start()
	if err != nil {
		ctx.Logger().Error(err)
		log.Println(err)
	}

	// websocket server, use to manage users subscription
	wsserver = ws.NewWS(ctx, wsclient, app)

	// lcd usecase
	lcd := lcdusecase.NewLcdUsecase(cdc)

	// block handler
	blockRepo := blockrepo.NewCockroachBlockRepository(db)
	block := busecase.NewBlockUsecase(blockRepo)
	bhandler.NewBlockHandler(ctx, g, block)

	// txs handler
	txsRepo := msgsrepo.NewCockroachMsgsRepository(db)
	txs := txsusecase.NewTxsUsecase(txsRepo)
	txshandler.NewTxsHandler(ctx, g, txs)

	// delegator handler
	delegatorRepo := delegatorrepo.NewCockroachDelegatorRepository(db)
	delegator := delegatorusecase.NewDelegatorUsecase(delegatorRepo)
	delegatorhandler.NewDelegatorHandler(ctx, g, delegator)

	// validator handler
	validatorRepo := validatorrepo.NewCockroachValidatorRepository(db)
	validator := validatorusecase.NewValidatorUsecase(validatorRepo)
	validatorhandler.NewValidatorHandler(ctx, g, validator)

	// transaction handler
	transactionRepo := txrepo.NewCockroachTransactionRepository(db)
	tx := txusecase.NewTransactionUsecase(transactionRepo, txsRepo)
	txhandler.NewTransactionHandler(ctx, g, tx)

	// wallet handler
	walletRepo := walletrepo.NewCockroachWalletRepository(db)
	wallet := walletusecase.NewWalletUsecase(walletRepo, delegatorRepo, validatorRepo, txsRepo, cdc)
	wallethandler.NewWalletHandler(ctx, g, wallet)

	// device handler
	deviceRepo := devicerepo.NewCockroachDeviceRepository(db)
	device := deviceusecase.NewDeviceUsecase(deviceRepo)
	devicehandler.NewDeviceHandler(ctx, g, app, device, wsclient)

	// staking handler
	stakingRepo := stakingrepo.NewCockroachStakingRepository(db)
	staking := stakingusecase.NewStakingUsecase(stakingRepo)
	stakinghandler.NewStakingHandler(ctx, g, staking)

	// statistic handler
	statRepo := statrepo.NewCockroachStatRepository(db)
	stst := statusecase.NewStatUsecase(statRepo, txs, block, tx, wallet, lcd, cdc)
	stathandler.NewStatHandler(ctx, g, stst)

	// node info handler
	nodeInfoRepo := noderepo.NewCockroachNodeInfoRepository(db)
	node := nodeusecase.NewNodeInfoUsecase(nodeInfoRepo)
	nodehandler.NewNodeHandler(ctx, g, node)

	// unban, blacklist, whitelist IPs
	v1 := e.Group("/api/admin")
	v1.Use(mw.BasicAuth(middleware.ValidateUser))
	blacklistRepo := blacklistrepo.NewBlacklistRepository(fileBlacklist, fileWhitelist, blacklistingIP, whitelistingIP)
	blacklist := blacklistusecase.NewBlacklistUsecase(blacklistRepo)
	blacklisthandler.NewBlacklistHandler(ctx, v1, blacklist)

	// start listening on websocket server
	e.GET("/swagger/*", echoSwagger.WrapHandler)

	// start websocket
	e.GET("/websocket", wsserver.ServeWebsocket)
	go wsserver.Run()

	// server starts here
	e.Logger.Fatal(e.Start(serverHostName))

}

func initCockroachDB() *gorm.DB {
	url := ""
	host := viper.GetString(`cockroachdb.host`)
	port := viper.GetString(`cockroachdb.port`)
	cruser := viper.GetString(`cockroachdb.user`)
	passwd := viper.GetString(`cockroachdb.password`)
	dbname := viper.GetString(`cockroachdb.dbname`)
	sslmode := viper.GetString(`cockroachdb.sslmode`)
	sslrootcert := viper.GetString(`cockroachdb.sslrootcert`)
	sslcert := viper.GetString(`cockroachdb.sslcert`)
	sslkey := viper.GetString(`cockroachdb.sslkey`)
	if sslmode == "disable" {
		url = fmt.Sprintf("user=%v host=%v port=%v dbname=%v",
			cruser, host, port, dbname)
	} else if sslmode == "require" {
		url = fmt.Sprintf("user=%v password=%v host=%v port=%v dbname=%v sslmode=%v sslrootcert=%v sslcert=%v sslkey=%v",
			cruser, passwd, host, port, dbname, sslmode, sslrootcert, sslcert, sslkey)
	} else {
		panic(errors.New("sslmode is undefined"))
	}

	c, err := gorm.Open(postgres.Open(url), &gorm.Config{
		DisableForeignKeyConstraintWhenMigrating: true,
		PrepareStmt:                              true,
		SkipDefaultTransaction:                   true,
	})
	if err != nil {
		panic(err)
	}

	c.Logger.LogMode(logger.Silent)
	//if err = c.AutoMigrate(domain.PnTokenDevice{}); err != nil {
	//	panic(err)
	//}
	return c
}

func initFirebase() *firebase.App {
	opt := option.WithCredentialsFile(firebaseCred)
	app, err := firebase.NewApp(context.Background(), nil, opt)
	if err != nil {
		panic(err)
	}
	return app
}

func onDisconnectFromWsNode() {
	// TODO: announce clients: node indexing is down, all subscriptions were lost
	if wsserver != nil {
		log.Println("Server Websocket disconnected from node")
		wsserver.Broadcast("client", "disconnect", "disconnected from node. Subscriptions were lost")
		// disconnect all clients
		wsserver.DisconnectAllClients()
	}
}

func onReconnectToWsNode() {
	// TODO: announce clients: node indexing is back, start re-subscribing
	if wsserver != nil {
		log.Println("Server Websocket reconnected to node")
		wsserver.Broadcast("client", "reconnect", "reconnected to node. Subscriptions are restarted")
		// re-subscribe FCM, notification, re-send subscription
		// only need to send message subscribe
		var wallets []string
		for {
			err := db.Model(&domain.PnTokenDevice{}).Distinct().Pluck("wallet", &wallets).Error
			if err != nil {
				continue
			} else {
				break
			}
		}
		wsserver.ResubscribeDeviceToken(wallets)
	}
}
